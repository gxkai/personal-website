<p>Redwood is an opinionated full-stack javascript web application framework. It is also serverless-ready, meaning it can be deployed <em>on the edge</em> with services like AWS Lambda and Cloudflare Workers. Redwood is <em>super</em> opinionated. It decides your project/directory structure, it decides the frameworks and libraries you use, and it configures everything for you. Some may see a downside to this, but if you're experienced with Redwood's choosing of frameworks, you will have a pleasant time using Redwood.Redwood was created by <a href=\"https://github.com/mojombo\">Tom Preston-Werner</a>. You may have heard of him before, because he is the guy behind- <a href=\"https://github.com\">Github</a>, which is the most popular code host- <a href=\"https://jekyllrb.com\">Jekyll</a>, a ruby-based static-site generator- <a href=\"https://gravatar.com\">Gravatar</a>, a very popular avatar service- <a href=\"https://semver.org\">Semver</a>, the semantic versioning system- <a href=\"https://toml.io\">TOML</a>, a configuration language, like JSON or YAML, and much more.## Prerequisites- Redwood uses <a href=\"https://reactjs.org\">React</a> for the frontend framework, so you'll need to know React.- Redwood uses <a href=\"https://graphql.org\">GraphQL</a> instead of REST APIs, so knowledge of that is <strong>required</strong>. You can learn it on the <a href=\"https://graphql.org/learn/\">official website</a>.- Redwood uses <a href=\"https://prisma.io\">Prisma</a> for interacting with databases, but it's very easy to use, and you can pick it up from this tutorial itself. Prisma works with SQL databases.- A <a href=\"https://postgresql.org\">Postgres</a> database running. You can either have the Postgres server installed, or use <a href=\"https://docker.com\">Docker</a>. I'll be doing the latter in this tutorial.- There are various other libraries used like <a href=\"https://jestjs.io\">Jest</a> and <a href=\"https://storybook.js.org\">Storybook</a>, but these are not needed to follow this tutorial.- I'll be using <a href=\"https://typescriptlang.org\">TypeScript</a> in this tutorial, but feel free to use plain JavaScript. Just be sure to remove any code that is TypeScript-specific.There are also a few things you'll need installed on your computer:- <a href=\"https://nodejs.org\">NodeJS</a> v14 or higher. I'll be using v16. (Psst: For an easy way to manage versions of NodeJS and many others, try <a href=\"https://asdf-vm.com\">https://asdf-vm.com</a>).- The <a href=\"https://yarnpkg.com\">Yarn</a> Package Manager installed. Redwood leverages yarn workspaces, so yarn is needed. You can install it using <code>npm i -g yarn</code>.- A powerful code editor like <a href=\"https://code.visualstudio.com\">VSCode</a> or (Neo)Vim. If you're using VSCode, be sure to install the Redwood extension.## Step 0 — Creating your Redwood appOpen an empty folder in your favorite IDE and run the below command in the terminal.<code>bashyarn create redwood-app .</code>If you're like me however, and you've fallen in love with <a href=\"https://typescriptlang.org\">TypeScript</a>, you can create a Redwood typescript app by adding the <code>--typescript</code> flag to the above command like so:<code>bashyarn create --typescript redwood-app .</code>&gt; If you want to convert an existing Redwood project to TypeScript, you can run <code>yarn rw setup tsconfig</code> and change your <code>.js</code> files to <code>.ts</code>.Now open the project in your favorite IDE. I'll use VSCode in this tutorial, since Redwood has first-class support for it. Launch the editor and open the folder, or just run <code>code .</code> in the terminal.You may be prompted to install recommended extensions, so feel free to install them all, or just some if you don't need certain extensions (like Gitlens, in my case).## Step 1 — Getting to know your projectLet's take a look at the project structure.There are a few files in the root project. Most of them are configuration files, like <code>jest.config.js</code>. Let's take a look at a specific file called <code>redwood.toml</code>.<code>toml[web]  title = &quot;Redwood App&quot;  port = 8910  apiUrl = &quot;/.redwood/functions&quot; # you can customise graphql and dbauth urls individually too: see https://redwoodjs.com/docs/app-configuration-redwood-toml#api-paths  includeEnvironmentVariables = [] # any ENV vars that should be available to the web side, see https://redwoodjs.com/docs/environment-variables#web[api]  port = 8911[browser]  open = true</code>&gt; Redwood recommends so many extensions, but not a TOML one! Install <a href=\"https://marketplace.visualstudio.com/items?itemName=bungcip.better-toml\">this extension</a> for VSCode for TOML highlighting.If you're unfamiliar with TOML syntax, don't worry, I'll guide you through the config. For now, let's change the <code>port</code> of both the <code>[web]</code> and <code>[api]</code> projects to <code>3000</code> and <code>5000</code> respectively.### Where your code livesThere are many directories, but the main two directories are <code>web</code>, and <code>api</code>. This is where your Redwood code lives. As the name suggests, <code>web</code> is the frontend project, and <code>api</code> is the backend project.These two directories are actually their own projects, and Redwood uses Yarn Workspaces to link these two folders together.<strong>Inside the <code>web</code> folder</strong>:<img src=\"https://i.imgur.com/AS7I7Lc.png\" alt=\"Screenshot of the subfolders inside the web folder\">The <code>web</code> folder is a regular ol' React application. If you know react, you should be able to read through the structure of this directory. There are just a few things that are different. In the <code>src</code> folder, you can see three more subfolders, <code>components</code>, <code>layouts</code> and <code>pages</code>. The <code>components</code> folder holds any re-usable React components. The <code>layouts</code> folder holds page layouts, which are also React components, and the <code>pages</code> folder, which contains React components mapped to routes.&gt; <strong>What is a <code>.keep</code> file?</strong>&gt; <code>.keep</code> files are just files that are placed in empty directories so they get committed to a git project. Git doesn't commit empty folders, so <code>.keep</code> files are created to make the folder <em>not empty</em>, and hence, get it committed. These <code>.keep</code> files don't even have to be called <code>.keep</code>, they can be called anything else, but by convention, they're called <code>.keep</code> and <code>.gitkeep</code>.<strong>Inside the <code>api</code> folder</strong>:<img src=\"https://i.imgur.com/1h7HAko.png\" alt=\"Screenshot of the folders inside the api folder\">The <code>api</code> folder is the backend server. This is running <code>fastify</code> under the hood, which is just a faster backend server than express. There are a few config files, and there are three subdirectories.The <code>db</code> folder contains the <code>schema.prisma</code> file, which is the schema for your database models that is used by Prisma ORM.The <code>src</code> folder contains all of your source code for the backend.&gt; From the <a href=\"https://learn.redwoodjs.com/docs/tutorial/redwood-file-structure\">redwood documentation</a>: * <code>directives</code> will contain GraphQL <a href=\"https://www.graphql-tools.com/docs/schema-directives\">schema directives</a> for controlling access to queries and transforming values.* <code>functions</code> will contain any <a href=\"https://docs.netlify.com/functions/overview/\">lambda functions</a> your app needs in addition to the <code>graphql.js</code> file auto-generated by Redwood. This file is required to use the GraphQL API.* <code>graphql</code> contains your GraphQL schema written in a Schema Definition Language (the files will end in <code>.sdl.js</code>).* <code>lib</code> contains a few files:<code>auth.js</code> starts as a placeholder for adding auth functionality and has a couple of bare-bones functions in it to start, <code>db.js</code> instantiates the Prisma database client so we can talk to a database and <code>logger.js</code> which configures, well, logging. You can use this directory for other code related to the API side that doesn't really belong anywhere else.* <code>services</code> contains business logic related to your data. When you're querying or mutating data for GraphQL (known as <strong>resolvers</strong>), that code ends up here, but in a format that's reusable in other places in your application.<strong>Start the server</strong>:Let's start the server by running the below command:<code>bashyarn rw dev</code>You should now see your application running on <a href=\"http://localhost:3000\">http://localhost:3000</a>, or <a href=\"http://localhost:8911\">http://localhost:8911</a>, if you didn't change the port in the config. The backend will run on port <code>5000</code>, or <code>8910</code> if you didn't change the port in the config.If this is what you see, you've successfully created your redwood project!<img src=\"https://i.imgur.com/1iBwiDg.png\" alt=\"Screenshot of localhost:3000\"><strong>Replacing SQLLite with Postgres</strong>:SQLLite is the default database used by Redwood, since it doesn't expect everyone to have a fully-fledged database installed and running on their computer. But SQLLite is a file-system based database, and it also lacks in features when compared to Postgres. A file-system based database isn't the best for production, so let's switch over to Postgres.Postgres needs to be installed on your computer. You can download it and install it, and have a system-wide install of postgres, or you can use <a href=\"https://docker.com\">Docker</a> to <em>containerize</em> it, which is easier to do. You'll need docker installed, however, and you can get it from <a href=\"https://www.docker.com/get-started\">here</a>.Once docker is running, you can create a <code>postgres</code> container using the command below:<code>bashdocker run -d -p 5432:5432 --name postgres -e POSTGRES_PASSWORD=YOUR_STRONG_PASSWORD postgres</code>&gt; Be sure to replace <code>YOUR_STRONG_PASSWORD</code> to a strong password, since that will be the password of your root account in postgres.The above command will run the <a href=\"https://hub.docker.com/_/postgres\"><code>postgres</code></a> image as a container, with the name <code>postgres</code> (with the <code>--name</code> flag), adds the environment variable <code>POSTGRES_PASSWORD</code> to it (with the <code>-e</code> flag), exposes port <code>5432</code> (postgres' default port) back to the host (with the <code>-p</code> flag) and finally, it runs it in the background with the <code>-d</code> flag.Now, create a new database in the fresh postgres container you just created. Run the below command to get <em>shell</em> access to the container:<code>bashdocker exec -it postgres bash</code>If your <em>shell prompt</em> changed, you now have the ability to run commands directly in the postgres container! Now run the below command to create a new database.<code>bashcreatedb -U postgres NAME_OF_YOUR_DATABASE</code>The <code>-U postgres</code> flag makes it run as the <code>postgres</code> user, which is the default root user. Change <code>NAME_OF_YOUR_DATABASE</code> to anything you want. In my case, I changed it to <code>reddit</code>, which means that a new database with the name <code>reddit</code> has been created for me. Once that's done, exit out of the shell by typing <code>exit</code> and hitting Enter.Now that you have a postgres database, you just need to tell Prisma to use it. Open the <code>.env</code> file in the project root and add the below code to it.<code>plainDATABASE_URL=postgres://postgres:YOUR_STRONG_PASSWORD@localhost:5432/YOUR_DATABASE_NAME</code>Be sure to replace <code>YOUR_STRONG_PASSWORD</code> and <code>YOUR_DATABASE_NAME</code> with the relevant values. And finally, change the line that says <code>provider = &quot;sqlite&quot;</code> to <code>provider = &quot;postgresql&quot;</code> in the <code>api/db/schema.prisma</code>.<code>prismadatasource db {  provider = &quot;postgresql&quot;  url      = env(&quot;DATABASE_URL&quot;)}</code>## Step 2 — Creating Prisma modelsPrisma models are definitions for how your database tables will look like. They are written in prisma's own model language in the <code>schema.prisma</code> file. If you're not familiar with this syntax, don't fear, since it looks similar to GraphQL syntax, and I'll guide you with it.### Creating the User modelOpen the <code>src/db/schema.prisma</code> file in the <code>api</code> project. Let's delete the example <code>UserExample</code> project, and replace it with our own User model.<code>prismamodel User {  id        String  @id @default(cuid()) @db.VarChar(255)  username  String  @unique  email     String  @unique  password  String  @db.VarChar(255)  avatarUrl String  @map(&quot;avatar_url&quot;)  roles     String  @default(&quot;member&quot;)  bio       String?  isBanned  Boolean @default(false)  @map(&quot;is_banned&quot;)    @@map(&quot;users&quot;)}</code>&gt; If you can't see any syntax highlighting, be sure to install the Prisma extension for VSCode.What the above Prisma code does, is it creates a model named <code>User</code>. A Prisma model is mapped to a table in the database, which in this case will be <code>users</code>, because of the <code>@@map(&quot;users&quot;)</code>. These are the fields that will be created:* An <code>id</code> filed, which will be the primary key (denoted by <code>@id</code>). It will be a String with the <code>VarChar</code> datatype in Postgres. Since <code>VarChar</code> isn't supported by all databases Prisma supports (like MongoDB), we have to use <code>@db.VarChar</code> instead of directly declaring it as a <code>VarChar</code> type. The <code>id</code> will also be a generated <code>CUID</code> by default. A CUID is a randomly-generated string, like a UUID.* A <code>username</code> and an <code>email</code> field, both of which are <code>String</code>s and are <code>unique</code>, meaning no two users can have the same <code>email</code> or <code>username</code>. By default, a <code>String</code> will be mapped to Postgres' <code>Text</code> datatype.* A <code>password</code>, which is a <code>String</code> in Prisma, but a <code>VarChar</code> in Postgres* An <code>avatarUrl</code>, which is a <code>String</code>. This will be accessed in JavaScript with <code>avatarUrl</code>, but will be stored in the database as <code>avatar_url</code>, because of <code>@map</code>. I did this because Postgres follows <code>snake_casing</code>, while JavaScript follows <code>camelCasing</code>.* A <code>roles</code>, which is a <code>String</code>, which will contain a comma-separated string of roles. You could use an array here, but I feel like that would be overkill for a field that would usually only have one role. Also <code>member</code> is the default.* A <code>bio</code>, which is an <em>optional</em> string (<code>nullable</code>, in database lingo). This is indicated by the <code>?</code> after <code>String</code>.* And finally, <code>isBanned</code>, which is a <code>Boolean</code> that defaults to <code>false</code>, and is stored as <code>is_banned</code> in the database.Now you need to sync the models to your database. Currently, they're only present in the <code>schema.prisma</code> file. To create the tables in the database, run the below command:<code>bashyarn redwood prisma migrate dev</code>&gt; You can use the alias <code>rw</code> instead of <code>redwood</code>, and that's what I'll be doing from now <a href=\"http://on.Be\">on.Be</a> sure to give it a meaningful name. Treat it like a git commit – the name should reflect the changes you've made. In this case, we've created a <code>User</code> model, so I named it <code>add-user-model</code>.Now your database will have a table called <code>users</code> with all these fields that you just defined.### Creating the Post modelNow it's time to create a model for holding our posts.<code>prismamodel Post {  id       String  @id @default(cuid()) @db.VarChar(255)  title    String  content  String  hasMedia Boolean @default(false) @map(&quot;has_media&quot;)  mediaUrl String?  authorId String  @map(&quot;user_id&quot;) @db.VarChar(255)  author   User    @relation(fields: [authorId], references: [id])  @@map(&quot;posts&quot;)}</code>&gt; You may see a squiggly line under the <code>author</code> field. Don't worry, we'll solve that soon.The fields in this model are pretty similar to the ones in the <code>User</code> model, except they have different names. There is one odd one out however, and that is <code>authorId</code>. This <code>authorId</code> field will point to the <code>id</code> of the <code>User</code> that created this post, and this is denoted by the <code>author User</code> line. It has an <code>@relation</code> directive that relates the <code>id</code> field of <code>User</code> to the <code>authorId</code> field of <code>Post</code>. Prisma also requires that we include a backref – a field on the other table that points back to this one indicating the relation. Since this will be a one-to-many (O2M) relation, i.e. one user can have many posts, the post backref in the User model should be an array. You can denote that by putting square brackets (<code>[]</code>) after the type, just like in regular TypeScript.<code>prismamodel User {  id        String  @id @default(cuid()) @db.VarChar(255)  username  String  @unique  email     String  @unique  password  String  @db.VarChar(255)  avatarUrl String  @map(&quot;avatar_url&quot;)  roles     String  @default(&quot;member&quot;)  bio       String?  isBanned  Boolean @default(false) @map(&quot;is_banned&quot;)  post      Post[]  // Add this line to your User model. This is the backref!  @@map(&quot;users&quot;)}model Post {  id       String  @id @default(cuid()) @db.VarChar(255)  title    String  content  String  hasMedia Boolean @default(false) @map(&quot;has_media&quot;)  mediaUrl String?  authorId String  @map(&quot;user_id&quot;) @db.VarChar(255)  author   User    @relation(fields: [authorId], references: [id])  @@map(&quot;posts&quot;)}</code>While we're at it, let's also add a <code>Comment</code> model, which will store comments on a post. This model will have two relations — both O2M — one with the <code>User</code> model, and the other with the <code>Post</code> model.<code>prismamodel User {  id        String  @id @default(cuid()) @db.VarChar(255)  username  String  @unique  email     String  @unique  password  String  @db.VarChar(255)  avatarUrl String  @map(&quot;avatar_url&quot;)  roles     String  @default(&quot;member&quot;)  bio       String?  isBanned  Boolean @default(false) @map(&quot;is_banned&quot;)  post     Post[]  // backref to Post  comments Comment[]  // backref to Comment  @@map(&quot;users&quot;)}model Post {  id       String  @id @default(cuid()) @db.VarChar(255)  title    String  content  String  hasMedia Boolean @default(false) @map(&quot;has_media&quot;)  mediaUrl String?  authorId String  @map(&quot;user_id&quot;) @db.VarChar(255)  author   User    @relation(fields: [authorId], references: [id])  comments Comment[]  // backref to Comment  @@map(&quot;posts&quot;)}// Our comment modelmodel Comment {  id       String @id @default(cuid()) @db.VarChar(255)  content  String  authorId String @map(&quot;user_id&quot;) @db.VarChar(255)  author   User   @relation(fields: [authorId], references: [id])  postId   String @map(&quot;post_id&quot;) @db.VarChar(255)  post     Post   @relation(fields: [postId], references: [id])  @@map(&quot;comments&quot;)}</code>You should notice that the fields that are in a relation have the same type as the field they're in a relationship with. This is important, since they'll be storing the same type of data.Let's migrate our database! Run the same command as before, and this time, you can give it a name directly in the command line with the <code>--name</code> argument.<code>bashyarn rw prisma migrate dev --name add-post-and-comment-models</code>With that, our three basic models have been created. Let's now use them in the Redwood project.## Step 2 — Adding authentication to your appRedwood makes it really easy to add authentication to your application. It handles almost everything that is boring, like sessions and stuff like that.Let's use the Redwood CLI and sets up authentication for you. Run the below command to do that:<code>bashyarn rw setup auth dbAuth</code>This will setup a local authentication provider that saves your users' credentials on the database. Redwood also supports some authentication-as-a-service providers out-of-the-box, like <a href=\"https://auth0.com\">Auth0</a> and <a href=\"https://magic.link\">Magic</a>. Read more about that <a href=\"https://redwoodjs.com/docs/authentication\">here</a>.A few new files have been created. You need to edit these files to make it work with your schema. First, let's edit <code>src/lib/auth.ts</code>. This file contains methods that are used by Redwood under-the-hood to determine if a user is authenticated and authorized to access a resource.You only need to do one small edit – make Redwood read the roles stored in the <code>users</code> table in the <code>hasRole</code> function. But first. let's make the <code>getCurrentUser</code> function return the whole user, instead of just the user's <code>id</code>:<code>typescriptexport const getCurrentUser = async (session) =&gt; {  return await db.user.findUnique({    where: { id: session.id },  })}</code>In the above snippet, I just removed the <code>select {...}</code> from the query so it returns all fields of the user. We can now use this in the <code>hasRole</code> function. Change out the <code>hasRole</code> function to the one below:<code>typescriptexport const hasRole = ({ roles }: { roles: AllowedRoles }): boolean =&gt; {  if (!isAuthenticated()) {    return false  }  // If your User model includes roles, uncomment the role checks on currentUser  if (roles) {    if (Array.isArray(roles)) {      // the line below has changed      if (context.currentUser.roles)        return context.currentUser.roles          .split(',')          .some((role) =&gt; roles.includes(role))    }    if (typeof roles === 'string') {      // the line below has changed      if (context.currentUser.roles)        return context.currentUser.roles.split(',').includes(roles)    }    // roles not found    return false  }  return true}</code>This code should now check the roles in the database instead of returning false by default.<strong>Adding some fields to the <code>User</code> model</strong>:Redwood gives you a <code>hashedPassword</code>, a <code>salt</code>, a <code>resetToken</code> and a <code>resetTokenExpiresAt</code> to store in your database, but the current <code>User</code> model can only store the password. Let's change that by adding three new fields to the <code>User</code> model by changing the <code>User</code> model in <code>schema.prisma</code> to this:<code>prismamodel User {  id            String    @id @default(cuid()) @db.VarChar(255)  username      String    @unique  email         String    @unique  password      String    @db.VarChar(255)  // added the below three lines  salt          String    @db.VarChar(255)  resetToken    String?   @db.VarChar(255)  resetTokenExp DateTime? @db.Timestamptz()  avatarUrl     String    @map(&quot;avatar_url&quot;)  roles         String    @default(&quot;member&quot;)  bio           String?  isBanned      Boolean   @default(false) @map(&quot;is_banned&quot;)  post     Post[]  comments Comment[]  @@map(&quot;users&quot;)}</code>&gt; If you were messing around and created a few users, your migration will fail because <code>salt</code> is empty, and <code>salt</code> is not allowed to be empty. So, just add <code>@default(&quot;&quot;)</code> to the <code>salt</code> field in the schema to ensure that already-existing users won't have <code>null</code> values for required fields.Next, migrate with the below command:<code>bashyarn rw prisma migrate dev --name add-fields-to-user</code>&gt; Of course, you can use your own migration name.Next, you'll need to generate types so Redwood knows about the new User.<code>bashyarn rw generate types</code>And finally, you need to restart the dev server. Press <code>Ctrl+C</code> (maybe twice) to stop the current running dev server and run <code>yarn rw dev</code> to start it again.<strong>Configuring authentication</strong>:There are just a few final changes you need to make to the <code>src/functions/auth.ts</code> file, such as setting an <code>avatarUrl</code>. For the <code>avatarUrl</code>, we'll use <a href=\"https://gravatar.com\">Gravatar</a>, which is a popular avatar service. For that, you just need to use the below URL as the <code>avatarUrl````plainhttps://gravatar.com/avatar/EMAIL_HASH?d=mp&amp;s=64```The </code>EMAIL_HASH<code>should be an</code>md5<code>hash of the user's email. For generating an</code>md5<code>hash, let's install the</code>md5<code>package (along with its typescript definitions) with the below commands:```bashyarn workspace api add md5 &amp;&amp; yarn workspace api add -D @types/md5```&gt; We're using</code>workspace api add<code>instead of just</code>add<code>because there are two workspaces here, and we just want to add</code>md5<code>to the</code>api<code>folder, not the</code>web<code>folder.Now, let's change the</code>src/functions/auth.ts<code>file to make sure it works with our requirements:```typescriptimport { db } from 'src/lib/db'import { DbAuthHandler } from '@redwoodjs/api'import md5 from 'md5'export const handler = async (event, context) =&gt; {  const forgotPasswordOptions = {    // handler() is invoked after verifying that a user was found with the given    // username. This is where you can send the user an email with a link to    // reset their password. With the default dbAuth routes and field names, the    // URL to reset the password will be:    //    // https://example.com/reset-password?resetToken=${user.resetToken}    //    // Whatever is returned from this function will be returned from    // the</code>forgotPassword()<code>function that is destructured from</code>useAuth()<code>   // You could use this return value to, for example, show the email    // address in a toast message so the user will know it worked and where    // to look for the email.    handler: (user) =&gt; {      return user    },    // How long the resetToken is valid for, in seconds (default is 24 hours)    expires: 60 * 60 * 24,    errors: {      // for security reasons you may want to be vague here rather than expose      // the fact that the email address wasn't found (prevents fishing for      // valid email addresses)      usernameNotFound: 'Email not found',      // if the user somehow gets around client validation      usernameRequired: 'Email is required',    },  }  const loginOptions = {    // handler() is called after finding the user that matches the    // username/password provided at login, but before actually considering them    // logged in. The</code>user<code>argument will be the user in the database that    // matched the username/password.    //    // If you want to allow this user to log in simply return the user.    //    // If you want to prevent someone logging in for another reason (maybe they    // didn't validate their email yet), throw an error and it will be returned    // by the</code>logIn()<code>function from</code>useAuth()<code message:=\"\" Error=\"\" message=\"\">in the form of:    //</code><code>   handler: (user) =&gt; {      return user    },    errors: {      usernameOrPasswordMissing: 'Both email and password are required',      usernameNotFound: 'Email ${username} not found',      // For security reasons you may want to make this the same as the      // usernameNotFound error so that a malicious user can't use the error      // to narrow down if it's the username or password that's incorrect      incorrectPassword: 'Incorrect password for ${username}',    },    // How long a user will remain logged in, in seconds    expires: 60 * 60 * 24 * 365 * 10,  }  const resetPasswordOptions = {    // handler() is invoked after the password has been successfully updated in    // the database. Returning anything truthy will automatically logs the user    // in. Return</code>false<code>otherwise, and in the Reset Password page redirect the    // user to the login page.    handler: (user) =&gt; {      return user    },    // If</code>false<code>then the new password MUST be different than the current one    allowReusedPassword: true,    errors: {      // the resetToken is valid, but expired      resetTokenExpired: 'resetToken is expired',      // no user was found with the given resetToken      resetTokenInvalid: 'resetToken is invalid',      // the resetToken was not present in the URL      resetTokenRequired: 'resetToken is required',      // new password is the same as the old password (apparently they did not forget it)      reusedPassword: 'Must choose a new password',    },  }  const signupOptions = {    // Whatever you want to happen to your data on new user signup. Redwood will    // check for duplicate usernames before calling this handler. At a minimum    // you need to save the</code>username<code>, </code>hashedPassword<code>and</code>salt<code>to your    // user table.</code>userAttributes<code>contains any additional object members that    // were included in the object given to the</code>signUp()<code>function you got    // from</code>useAuth()<code>.    //    // If you want the user to be immediately logged in, return the user that    // was created.    //    // If this handler throws an error, it will be returned by the </code>signUp()<code error:=\"\" Error=\"\" message=\"\">   // function in the form of:</code><code>.    //    // If this returns anything else, it will be returned by the    // </code>signUp()<code message:=\"\" String=\"\" here=\"\">function in the form of:</code><code>.    handler: (payload) =&gt; {      const { username: email, hashedPassword, salt, userAttributes } = payload      return db.user.create({        data: {          email,          password: hashedPassword,          avatarUrl: </code><a href=\"https://gravatar.com/avatar/$%7Bmd5(email)%7D?d=mp&amp;s=64\">https://gravatar.com/avatar/${md5(email)}?d=mp&amp;s=64</a><code>,          salt: salt,          username: userAttributes.name,        },      })    },    errors: {      // </code>field<code>will be either &quot;username&quot; or &quot;password&quot;      fieldMissing: '${field} is required',      usernameTaken: 'Email</code>${username}<code>already in use',    },  }  const authHandler = new DbAuthHandler(event, context, {    // Provide prisma db client    db: db,    // The name of the property you'd call on</code>db<code>to access your user table.    // ie. if your Prisma model is named</code>User<code>this value would be</code>user<code>, as in </code>db.user<code>   authModelAccessor: 'user',    // A map of what dbAuth calls a field to what your database calls it.    //</code>id<code>is whatever column you use to uniquely identify a user (probably    // something like</code>id<code>or</code>userId<code>or even</code>email<code>)    authFields: {      id: 'id',      username: 'email',      hashedPassword: 'password',      salt: 'salt',      resetToken: 'resetToken',      resetTokenExpiresAt: 'resetTokenExp',    },    forgotPassword: forgotPasswordOptions,    login: loginOptions,    resetPassword: resetPasswordOptions,    signup: signupOptions,  })  return await authHandler.invoke()}```All I did above was change the </code>hashedPassword<code>field to</code>password<code>, and the </code>username<code>field to</code>email<code>. I also replaced instances of </code>Username<code>in messages to</code>Email<code>, and I added the </code>avatarUrl<code>field.### Adding login and signup pagesLet's add login and signup pages to the frontend. Redwood makes this really easy by providing a generator for us. Run the below command to create a login page, a signup page, and a forgot and reset password page.```bashyarn rw g dbAuth```I will delete the</code>ForgotPassword<code>and</code>ResetPassword<code>pages, since I won't be adding that functionality to this project.Next, you need to replace the</code>username<code>field in both Login and SignUp to</code>email<code>, and in SignUp, add a new field called username. I've done it below and here's how your code should look like:```typescript// Routes.tsximport { Router, Route } from '@redwoodjs/router'const Routes = () =&gt; {  return (    &lt;Router&gt;      &lt;Route path=&quot;/login&quot; page={LoginPage} name=&quot;login&quot; /&gt;      &lt;Route path=&quot;/signup&quot; page={SignupPage} name=&quot;signup&quot; /&gt;      &lt;Route notfound page={NotFoundPage} /&gt;    &lt;/Router&gt;  )}export default Routes``````typescript// LoginPage.tsximport { Link, navigate, routes } from '@redwoodjs/router'import { useRef } from 'react'import {  Form,  Label,  TextField,  PasswordField,  Submit,  FieldError,} from '@redwoodjs/forms'import { useAuth } from '@redwoodjs/auth'import { MetaTags } from '@redwoodjs/web'import { toast, Toaster } from '@redwoodjs/web/toast'import { useEffect } from 'react'const LoginPage = () =&gt; {  const { isAuthenticated, logIn } = useAuth()  useEffect(() =&gt; {    if (isAuthenticated) {      navigate(routes.home())    }  }, [isAuthenticated])  const emailRef = useRef&lt;HTMLInputElement&gt;()  useEffect(() =&gt; {    emailRef.current.focus()  }, [])  const onSubmit = async (data) =&gt; {    const response = await logIn({ ...data })    if (response.message) {      toast(response.message)    } else if (response.error) {      toast.error(response.error)    } else {      toast.success('Welcome back!')    }  }  return (    &lt;&gt;      &lt;MetaTags title=&quot;Login&quot; /&gt;      &lt;main className=&quot;rw-main&quot;&gt;        &lt;Toaster toastOptions={{ className: 'rw-toast', duration: 6000 }} /&gt;        &lt;div className=&quot;rw-scaffold rw-login-container&quot;&gt;          &lt;div className=&quot;rw-segment&quot;&gt;            &lt;header className=&quot;rw-segment-header&quot;&gt;              &lt;h2 className=&quot;rw-heading rw-heading-secondary&quot;&gt;Login&lt;/h2&gt;            &lt;/header&gt;            &lt;div className=&quot;rw-segment-main&quot;&gt;              &lt;div className=&quot;rw-form-wrapper&quot;&gt;                &lt;Form onSubmit={onSubmit} className=&quot;rw-form-wrapper&quot;&gt;                  &lt;Label                    name=&quot;username&quot;                    className=&quot;rw-label&quot;                    errorClassName=&quot;rw-label rw-label-error&quot;                  &gt;                    Email                  &lt;/Label&gt;                  &lt;TextField                    name=&quot;username&quot;                    className=&quot;rw-input&quot;                    errorClassName=&quot;rw-input rw-input-error&quot;                    ref={emailRef}                    validation={{                      required: {                        value: true,                        message: 'Email is required',                      },                    }}                  /&gt;                  &lt;FieldError name=&quot;username&quot; className=&quot;rw-field-error&quot; /&gt;                  &lt;Label                    name=&quot;password&quot;                    className=&quot;rw-label&quot;                    errorClassName=&quot;rw-label rw-label-error&quot;                  &gt;                    Password                  &lt;/Label&gt;                  &lt;PasswordField                    name=&quot;password&quot;                    className=&quot;rw-input&quot;                    errorClassName=&quot;rw-input rw-input-error&quot;                    autoComplete=&quot;current-password&quot;                    validation={{                      required: {                        value: true,                        message: 'Password is required',                      },                    }}                  /&gt;                  &lt;FieldError name=&quot;password&quot; className=&quot;rw-field-error&quot; /&gt;                  &lt;div className=&quot;rw-button-group&quot;&gt;                    &lt;Submit className=&quot;rw-button rw-button-blue&quot;&gt;Login&lt;/Submit&gt;                  &lt;/div&gt;                &lt;/Form&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;div className=&quot;rw-login-link&quot;&gt;            &lt;span&gt;Don&amp;apos;t have an account?&lt;/span&gt;{' '}            &lt;Link to={routes.signup()} className=&quot;rw-link&quot;&gt;              Sign up!            &lt;/Link&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/main&gt;    &lt;/&gt;  )}export default LoginPage``````typescriptimport { Link, navigate, routes } from '@redwoodjs/router'import { useRef } from 'react'import {  Form,  Label,  TextField,  PasswordField,  FieldError,  Submit,} from '@redwoodjs/forms'import { useAuth } from '@redwoodjs/auth'import { MetaTags } from '@redwoodjs/web'import { toast, Toaster } from '@redwoodjs/web/toast'import { useEffect } from 'react'const SignupPage = () =&gt; {  const { isAuthenticated, signUp } = useAuth()  useEffect(() =&gt; {    if (isAuthenticated) {      navigate(routes.home())    }  }, [isAuthenticated])  // focus on email box on page load  const emailRef = useRef&lt;HTMLInputElement&gt;()  useEffect(() =&gt; {    emailRef.current.focus()  }, [])  const onSubmit = async (data) =&gt; {    const response = await signUp({ ...data })    if (response.message) {      toast(response.message)    } else if (response.error) {      toast.error(response.error)    } else {      // user is signed in automatically      toast.success('Welcome!')    }  }  return (    &lt;&gt;      &lt;MetaTags title=&quot;Signup&quot; /&gt;      &lt;main className=&quot;rw-main&quot;&gt;        &lt;Toaster toastOptions={{ className: 'rw-toast', duration: 6000 }} /&gt;        &lt;div className=&quot;rw-scaffold rw-login-container&quot;&gt;          &lt;div className=&quot;rw-segment&quot;&gt;            &lt;header className=&quot;rw-segment-header&quot;&gt;              &lt;h2 className=&quot;rw-heading rw-heading-secondary&quot;&gt;Signup&lt;/h2&gt;            &lt;/header&gt;            &lt;div className=&quot;rw-segment-main&quot;&gt;              &lt;div className=&quot;rw-form-wrapper&quot;&gt;                &lt;Form onSubmit={onSubmit} className=&quot;rw-form-wrapper&quot;&gt;                  &lt;Label                    name=&quot;username&quot;                    className=&quot;rw-label&quot;                    errorClassName=&quot;rw-label rw-label-error&quot;                  &gt;                    Email                  &lt;/Label&gt;                  &lt;TextField                    name=&quot;username&quot;                    className=&quot;rw-input&quot;                    errorClassName=&quot;rw-input rw-input-error&quot;                    ref={emailRef}                    validation={{                      required: {                        value: true,                        message: 'Email is required',                      },                    }}                  /&gt;                  &lt;FieldError name=&quot;username&quot; className=&quot;rw-field-error&quot; /&gt;                  &lt;Label                    name=&quot;name&quot;                    className=&quot;rw-label&quot;                    errorClassName=&quot;rw-label rw-label-error&quot;                  &gt;                    Username                  &lt;/Label&gt;                  &lt;TextField                    name=&quot;name&quot;                    className=&quot;rw-input&quot;                    errorClassName=&quot;rw-input rw-input-error&quot;                    ref={emailRef}                    validation={{                      required: {                        value: true,                        message: 'Username is required',                      },                    }}                  /&gt;                  &lt;FieldError name=&quot;name&quot; className=&quot;rw-field-error&quot; /&gt;                  &lt;Label                    name=&quot;password&quot;                    className=&quot;rw-label&quot;                    errorClassName=&quot;rw-label rw-label-error&quot;                  &gt;                    Password                  &lt;/Label&gt;                  &lt;PasswordField                    name=&quot;password&quot;                    className=&quot;rw-input&quot;                    errorClassName=&quot;rw-input rw-input-error&quot;                    autoComplete=&quot;current-password&quot;                    validation={{                      required: {                        value: true,                        message: 'Password is required',                      },                    }}                  /&gt;                  &lt;FieldError name=&quot;password&quot; className=&quot;rw-field-error&quot; /&gt;                  &lt;div className=&quot;rw-button-group&quot;&gt;                    &lt;Submit className=&quot;rw-button rw-button-blue&quot;&gt;                      Sign Up                    &lt;/Submit&gt;                  &lt;/div&gt;                &lt;/Form&gt;              &lt;/div&gt;            &lt;/div&gt;          &lt;/div&gt;          &lt;div className=&quot;rw-login-link&quot;&gt;            &lt;span&gt;Already have an account?&lt;/span&gt;{' '}            &lt;Link to={routes.login()} className=&quot;rw-link&quot;&gt;              Log in!            &lt;/Link&gt;          &lt;/div&gt;        &lt;/div&gt;      &lt;/main&gt;    &lt;/&gt;  )}export default SignupPage```&gt; Notice how I've only changed the text but not the </code>name<code>of the inputs? This is because under-the-hood, Redwood still expects your</code>email<code>to be called</code>username<code>.For one final step, let's add a home page so we don't have to see the Redwood logo anymore. Use the below command to generate an index page at </code>/<code>.```bashyarn rw g page home /```This command will generate a page called </code>home<code>, but map it to </code>/<code>, instead of </code>/home<code>. Change the code of the newly created </code>HomePage.tsx` to this:<code>typescriptimport { MetaTags } from '@redwoodjs/web'const HomePage = () =&gt; {  return (    &lt;&gt;      &lt;MetaTags        title=&quot;Redwoodit&quot;        description=&quot;A clone of Reddit using RedwoodJS&quot;      /&gt;      &lt;h1&gt;Redwoodit&lt;/h1&gt;    &lt;/&gt;  )}export default HomePage</code>And with that, you've added authentication to your Redwood application.If you visit <a href=\"http://localhost:3000/signup\">http://localhost:3000/signup</a>, you can create an account and if you visit <a href=\"http://localhost:3000/login\">http://localhost:3000/login</a>, you can log in to an account.## ConclusionYou've successfully created a Redwood application and added authentication to it. In the next part of this tutorial, you will add support for fetching, creating, updating and deleting posts and comments. If you've gotten stuck anywhere, be sure to check out the <a href=\"https://gitlab.com/arnu515-tutorials/reddit-clone-with-redwoodjs\">source code</a>, the <a href=\"https://redwoodjs.com/docs\">Redwood documentation</a>, or ask in the <a href=\"https://discord.gg/jjSYEQd\">Redwood Discord</a>/<a href=\"https://community.redwoodjs.com/\">Discourse Forums</a> for help.Stay tuned for Part 2!</p>
